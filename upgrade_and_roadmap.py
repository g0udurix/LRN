#!/usr/bin/env python3
# One-shot Project Management bootstrapper for LRN ‚Äî run & it will self-flush.
# Last generated by assistant at runtime ‚Äî this file will replace itself with a bootloader after --apply.

from __future__ import annotations
import os, sys, json, subprocess, shutil, urllib.request, urllib.error, time
from pathlib import Path
from datetime import datetime, timezone

REPO_SLUG = os.getenv("LRN_REPO", "g0udurix/LRN")
PROJECT_URL = os.getenv("LRN_PROJECT_URL", "https://github.com/users/g0udurix/projects/3")
APPLY = "--apply" in sys.argv

def ts() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

def log(msg: str):
    print(msg)
    try:
        Path("logs").mkdir(exist_ok=True)
        with open(Path("logs")/f"pm_{datetime.now(timezone.utc).strftime('%Y%m%dT%H%M%SZ')}.log", "a", encoding="utf-8") as f:
            f.write(msg+"\n")
    except Exception:
        pass

def run(cmd, cwd: Path|None=None, check=False):
    shell = isinstance(cmd, str)
    p = subprocess.run(cmd, cwd=(str(cwd) if cwd else None), capture_output=True, text=True, shell=shell)
    out, err = (p.stdout or "").strip(), (p.stderr or "").strip()
    cmd_str = cmd if shell else " ".join(cmd)
    err_part = ("\n" + err) if err else ""
    log(f"$ {cmd_str}\n[rc={p.returncode}]\n{out}{err_part}")
    if check and p.returncode != 0:
        raise RuntimeError(f"Command failed rc={p.returncode}: {cmd}\n{err}")
    return p.returncode, out, err

# --- Branch detection ------------------------------------------------------------

def default_branch_from_git() -> str|None:
    rc, out, _ = run(["git","symbolic-ref","refs/remotes/origin/HEAD"], check=False)
    if rc==0 and out:
        # refs/remotes/origin/HEAD -> refs/remotes/origin/<branch>
        return out.strip().split("/")[-1]
    rc, out, _ = run(["git","rev-parse","--abbrev-ref","origin/HEAD"], check=False)
    if rc==0 and out:
        return out.strip().split("/")[-1]
    return None

def default_branch_from_api() -> str|None:
    try:
        with urllib.request.urlopen(f"https://api.github.com/repos/{REPO_SLUG}") as r:
            info = json.loads(r.read().decode("utf-8"))
            return info.get("default_branch")
    except Exception:
        return None

def get_default_branch() -> str:
    b = default_branch_from_git() or default_branch_from_api() or "master"
    return b

# --- File helpers ----------------------------------------------------------------

def ensure_file(path: Path, content: str):
    name = f"ensure {path}"
    if path.exists() and path.read_text(encoding="utf-8") == content:
        log(f"[OK] {name} ‚Äî up-to-date")
        return False
    if APPLY:
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(content, encoding="utf-8")
        log(f"[APPLIED] {name} ‚Äî written")
        return True
    else:
        log(f"[OK] {name} ‚Äî would write (dry-run)")
        return False

# --- Content payloads ------------------------------------------------------------

ADD_TO_PROJECT = f"""
name: Add new items to Project
on:
  issues:
    types: [opened, reopened, transferred, labeled]
  pull_request:
    types: [opened, reopened, labeled, ready_for_review]
jobs:
  add:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/add-to-project@v1
        with:
          project-url: {PROJECT_URL}
          github-token: ${{{{ secrets.ADD_TO_PROJECT_PAT }}}}
"""

SET_FIELDS = f"""
name: Set Project fields from labels
on:
  issues:
    types: [opened, labeled, unlabeled, reopened, edited]
  pull_request:
    types: [opened, labeled, unlabeled, reopened, edited, ready_for_review]
  workflow_dispatch:
jobs:
  set-fields:
    runs-on: ubuntu-latest
    steps:
      - name: Derive values from labels
        id: derive
        uses: actions/github-script@v7
        with:
          script: |
            const payload = context.payload.issue || context.payload.pull_request;
            const labels = (payload.labels || []).map(l => l.name);
            function has(name) {{ return labels.some(n => n.toLowerCase() === name.toLowerCase()); }}
            let status = 'Todo';
            if (has('status/Blocked')) status = 'Blocked';
            else if (has('status/Doing')) status = 'Doing';
            else if (has('status/Review')) status = 'Review';
            else if (has('status/Done')) status = 'Done';
            else if (has('status/Backlog') || has('needs-triage')) status = 'Backlog';
            let priority = 'P2';
            if (has('priority/P0')) priority = 'P0';
            else if (has('priority/P1')) priority = 'P1';
            else if (has('priority/P2')) priority = 'P2';
            core.setOutput('Status', status);
            core.setOutput('Priority', priority);
      - uses: leonsteinhaeuser/project-fields@v2
        with:
          github_token: ${{{{ secrets.PROJECT_PAT }}}}
          project_url: {PROJECT_URL}
          fields: Status,Priority
          values: ${{{{ steps.derive.outputs.Status }}}},${{{{ steps.derive.outputs.Priority }}}}
"""

SYNC_LABELS_WF = """
name: Nightly labels sync
on:
  schedule:
    - cron: '30 3 * * *'
  workflow_dispatch:
jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Sync labels
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python scripts/labels_sync.py --repo "${{ github.repository }}"
"""

LABELS_SYNC_PY = r'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Idempotent labels sync (uses GitHub API)."""
import os, sys, json, argparse, urllib.request, urllib.parse, urllib.error
LABELS = [
    ("priority/P0","Blocker","b60205"),("priority/P1","High","d73a4a"),("priority/P2","Normal","fbca04"),
    ("area/extractor","Ingestion & crawling","1d76db"),("area/schema","Database schema/migrations","1d76db"),
    ("area/standards","Standards mapping","1d76db"),("area/comparison","Matrix/ranking engine","1d76db"),
    ("area/annotations","Notes, issues, orientations","1d76db"),("area/app","API/UI","1d76db"),
    ("jurisdiction/QC","Qu√©bec","0e8a16"),("jurisdiction/CA","Canada (Fed)","0e8a16"),
    ("jurisdiction/US","United States","0e8a16"),("jurisdiction/UK","United Kingdom","0e8a16"),
    ("jurisdiction/FR","France","0e8a16"),("jurisdiction/DE","Germany","0e8a16"),
    ("jurisdiction/JP","Japan","0e8a16"),("jurisdiction/AU","Australia","0e8a16"),
    ("standard/CSA","CSA","5319e7"),("standard/ANSI","ANSI","5319e7"),("standard/ISO","ISO","5319e7"),
    ("standard/EN","EN","5319e7"),("standard/BS","BSI","5319e7"),("standard/AS","AS/NZS","5319e7"),
    ("standard/JIS","JIS","5319e7"),("documentation","Docs & READMEs","c5def5"),("needs-triage","New items to triage","ededed"),
    ("status/Backlog","Backlog","8b949e"),("status/Todo","To-do","8b949e"),("status/Doing","In progress","8b949e"),
    ("status/Blocked","Blocked","d93f0b"),("status/Review","In review","a371f7"),("status/Done","Done","0e8a16"),
]
API="https://api.github.com"
class Api:
  def __init__(self, tok): self.tok=tok
  def call(self, m, p, d=None):
    u=API+p; r=urllib.request.Request(u, method=m); r.add_header('Accept','application/vnd.github+json');
    if self.tok: r.add_header('Authorization', f'Bearer {self.tok}')
    b=None
    if d is not None:
      b=json.dumps(d).encode('utf-8'); r.add_header('Content-Type','application/json')
    try:
      with urllib.request.urlopen(r,b) as resp:
        raw=resp.read().decode('utf-8'); return resp.getcode(), (json.loads(raw) if raw else None)
    except urllib.error.HTTPError as e:
      raw=e.read().decode('utf-8');
      try: pl=json.loads(raw)
      except Exception: pl=raw
      return e.code, pl

def up(api, owner, repo, name, color, desc):
  c,_=api.call('POST', f'/repos/{owner}/{repo}/labels', {'name':name,'color':color,'description':desc})
  if c in (200,201): print('[created]',name); return True
  c2,_=api.call('PATCH', f"/repos/{owner}/{repo}/labels/{urllib.parse.quote(name, safe='')}", {'new_name':name,'color':color,'description':desc})
  if c2==200: print('[updated]',name); return True
  print('[failed]', name, 'codes', c, c2); return False

def main():
  import argparse
  ap=argparse.ArgumentParser(); ap.add_argument('--repo',required=True); args=ap.parse_args(); owner,repo=args.repo.split('/')
  tok=os.getenv('LABELS_SYNC_PAT') or os.getenv('GITHUB_TOKEN') or os.getenv('GH_TOKEN')
  if not tok: print('ERROR: set GITHUB_TOKEN'); sys.exit(2)
  api=Api(tok); ok=True
  for n,d,c in LABELS: ok=up(api, owner, repo, n, c, d) and ok
  sys.exit(0 if ok else 1)
if __name__=='__main__': main()
'''

ISSUE_TEMPLATE_CONFIG = f"""
blank_issues_enabled: false
contact_links:
  - name: Project board (LRN #3)
    url: {PROJECT_URL}
    about: Track status, priorities and phases here
  - name: Read the README first
    url: https://github.com/{REPO_SLUG}
    about: Setup, CLI, and contribution guidelines
"""

LABELER_YML = """
area/extractor:
  - lrn/**
area/schema:
  - upgrade_and_roadmap.py
  - **/*.sql
  - **/*.db
area/standards:
  - standards/**
  - **/standards*.md
area/comparison:
  - **/matrix*/**
area/annotations:
  - **/guides/**
  - **/qa/**
area/app:
  - api/**
  - app/**
"""

LABELER_WF = """
name: PR Labeler
on:
  pull_request:
    types: [opened, synchronize]
jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/labeler@v5
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          sync-labels: true
"""

RELEASE_DRAFTER = """
name-template: 'LRN v$NEXT_PATCH_VERSION'
tag-template: 'v$NEXT_PATCH_VERSION'
categories:
  - title: üöÄ Features
    labels: [enhancement]
  - title: üêõ Fixes
    labels: [bug]
  - title: üßπ Maintenance
    labels: [chore, documentation]
change-template: '- $TITLE (#$NUMBER) by @$AUTHOR\n'
no-changes-template: 'No user-facing changes.'
"""

RELEASE_DRAFTER_WF = """
name: Release Drafter
on:
  push:
    branches: [ $default-branch ]
  pull_request:
    types: [closed]
permissions:
  contents: write
jobs:
  update_release_draft:
    runs-on: ubuntu-latest
    steps:
      - uses: release-drafter/release-drafter@v6
        with:
          config-name: release-drafter.yml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
"""

DEPENDABOT = """
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
  - package-ecosystem: "pip"
    directory: "/"
    schedule:
      interval: "weekly"
"""

CODEOWNERS = """
# Default owner
* @g0udurix
"""

EPIC_TEMPLATE = """
---
name: Epic
about: Track a multi-issue initiative
labels: [epic, needs-triage]
---
## Goal

## Why now

## Scope

## Done when
- [ ] ...
"""

TECH_DEBT_TEMPLATE = """
---
name: Tech debt
about: Code cleanup, refactor, or infra work
labels: [tech-debt, needs-triage]
---
## Problem

## Proposal

## Risk
"""

SEMANTIC_PR_WF = """
name: Semantic PR
on:
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review]
jobs:
  semantic:
    runs-on: ubuntu-latest
    steps:
      - uses: amannn/action-semantic-pull-request@v5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          types: |-
            feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert
"""

# --- Ensure all files ------------------------------------------------------------

def ensure_all(repo_dir: Path):
    wrote = False
    wrote |= ensure_file(repo_dir/".github"/"workflows"/"add_to_project.yml", ADD_TO_PROJECT)
    wrote |= ensure_file(repo_dir/".github"/"workflows"/"project_fields.yml", SET_FIELDS)
    wrote |= ensure_file(repo_dir/".github"/"workflows"/"sync_labels.yml", SYNC_LABELS_WF)
    wrote |= ensure_file(repo_dir/".github"/"workflows"/"labeler.yml", LABELER_WF)
    wrote |= ensure_file(repo_dir/".github"/"workflows"/"release-drafter.yml", RELEASE_DRAFTER_WF)
    wrote |= ensure_file(repo_dir/".github"/"release-drafter.yml", RELEASE_DRAFTER)
    wrote |= ensure_file(repo_dir/".github"/"dependabot.yml", DEPENDABOT)
    wrote |= ensure_file(repo_dir/".github"/"ISSUE_TEMPLATE"/"config.yml", ISSUE_TEMPLATE_CONFIG)
    wrote |= ensure_file(repo_dir/".github"/"ISSUE_TEMPLATE"/"epic.md", EPIC_TEMPLATE)
    wrote |= ensure_file(repo_dir/".github"/"ISSUE_TEMPLATE"/"tech_debt.md", TECH_DEBT_TEMPLATE)
    wrote |= ensure_file(repo_dir/".github"/"labeler.yml", LABELER_YML)
    wrote |= ensure_file(repo_dir/"CODEOWNERS", CODEOWNERS)
    wrote |= ensure_file(repo_dir/"scripts"/"labels_sync.py", LABELS_SYNC_PY)
    return wrote

# --- Label sync via gh or API ----------------------------------------------------

def sync_labels():
    if shutil.which("gh"):
        # create/update core labels (use --force to update desc/color)
        label_args = [
          ("priority/P0","Blocker","b60205"),("priority/P1","High","d73a4a"),("priority/P2","Normal","fbca04"),
          ("documentation","Docs & READMEs","c5def5"),("needs-triage","New items to triage","ededed"),
          ("status/Backlog","Backlog","8b949e"),("status/Todo","To-do","8b949e"),("status/Doing","In progress","8b949e"),
          ("status/Blocked","Blocked","d93f0b"),("status/Review","In review","a371f7"),("status/Done","Done","0e8a16"),
        ]
        for name, desc, color in label_args:
            run(["gh","label","create",name,"-R",REPO_SLUG,"--color",color,"--description",desc,"--force"])
        # areas, jurisdictions, standards
        more = [
          ("area/extractor","Ingestion & crawling","1d76db"),("area/schema","Database schema/migrations","1d76db"),
          ("area/standards","Standards mapping","1d76db"),("area/comparison","Matrix/ranking engine","1d76db"),
          ("area/annotations","Notes, issues, orientations","1d76db"),("area/app","API/UI","1d76db"),
          ("jurisdiction/QC","Qu√©bec","0e8a16"),("jurisdiction/CA","Canada (Fed)","0e8a16"),("jurisdiction/US","United States","0e8a16"),
          ("jurisdiction/UK","United Kingdom","0e8a16"),("jurisdiction/FR","France","0e8a16"),("jurisdiction/DE","Germany","0e8a16"),
          ("jurisdiction/JP","Japan","0e8a16"),("jurisdiction/AU","Australia","0e8a16"),
          ("standard/CSA","CSA","5319e7"),("standard/ANSI","ANSI","5319e7"),("standard/ISO","ISO","5319e7"),
          ("standard/EN","EN","5319e7"),("standard/BS","BSI","5319e7"),("standard/AS","AS/NZS","5319e7"),("standard/JIS","JIS","5319e7"),
        ]
        for name, desc, color in more:
            run(["gh","label","create",name,"-R",REPO_SLUG,"--color",color,"--description",desc,"--force"])
        return True
    else:
        # fallback: rely on nightly workflow using scripts/labels_sync.py
        return False

# --- Git ops ---------------------------------------------------------------------

def git_pull(repo_dir: Path):
    if not (repo_dir/".git").exists():
        log("[WARN] not a git repo, skipping pull")
        return
    run(["git","fetch","--all"], cwd=repo_dir)
    run(["git","pull","--rebase","--autostash"], cwd=repo_dir)

def git_commit_push(repo_dir: Path, message: str):
    if not (repo_dir/".git").exists():
        log("[WARN] not a git repo, skipping commit/push"); return False
    run(["git","add","-A"], cwd=repo_dir)
    rc,_,_ = run(["git","diff","--cached","--quiet"], cwd=repo_dir)
    if rc==0:
        log("[OK] no changes to commit"); return False
    run(["git","commit","-m", message], cwd=repo_dir)
    run(["git","push"], cwd=repo_dir)
    return True

# --- Self-flush bootloader -------------------------------------------------------

def write_bootloader(repo_dir: Path, branch: str):
    raw = f"https://raw.githubusercontent.com/{REPO_SLUG}/{branch}/upgrade_and_roadmap.py"
    stub = f"""#!/usr/bin/env python3
# upgrade_and_roadmap.py bootloader ‚Äî last run completed at {ts()} UTC
import sys, urllib.request
RAW = "{raw}"
try:
    data = urllib.request.urlopen(RAW, timeout=30).read()
    open(__file__, "wb").write(data)
    print("[bootloader] refreshed upgrade_and_roadmap.py from", RAW)
    print("[bootloader] run it again to execute the latest version.")
except Exception as e:
    print("[bootloader] failed to refresh:", e)
    sys.exit(1)
"""
    Path(__file__).write_text(stub, encoding="utf-8")

# --- Main ------------------------------------------------------------------------

def main():
    repo_dir = Path.cwd()
    branch = get_default_branch()
    log(f"[info] repo={REPO_SLUG} default_branch={branch} apply={APPLY}")

    git_pull(repo_dir)

    changed = ensure_all(repo_dir)
    if sync_labels():
        log("[APPLIED] labels synchronized via gh")
    else:
        log("[OK] gh absent: nightly sync workflow will enforce labels")

    if APPLY:
        did_push = git_commit_push(repo_dir, f"chore(project): bootstrap PM artifacts ({ts()})")
        write_bootloader(repo_dir, branch)
        log("[APPLIED] self-flush bootloader written")
        if did_push:
            log("[DONE] changes committed and pushed")
        else:
            log("[DONE] nothing to commit")
    else:
        log("[DRY-RUN] pass --apply to write files and commit")

if __name__ == "__main__":
    main()
